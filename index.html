# exoplanet.mobile.html.min
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>COM 궤도 시뮬레이터 (COM 항상 표시)</title>
<style>
  html,body{margin:0;background:#000;color:#fff;font-family:system-ui,-apple-system,sans-serif;overflow:hidden;}
  #hud{position:fixed;top:0;left:0;width:100%;z-index:3;background:rgba(0,0,0,0.6);padding:8px 14px;box-sizing:border-box;line-height:1.5}
  #ui{position:fixed;bottom:0;left:0;width:100%;z-index:3;background:rgba(20,20,20,0.96);
      padding:12px 16px;display:flex;flex-wrap:wrap;gap:12px 18px;align-items:center;justify-content:center;box-sizing:border-box}
  label{display:flex;align-items:center;gap:6px;font-size:14px;white-space:nowrap}
  input[type=range]{width:160px} input[type=number]{width:80px}
  button{background:#3b82f6;color:#fff;border:0;padding:8px 14px;border-radius:8px;font-weight:700;cursor:pointer}
  canvas{display:block;position:absolute;left:0;z-index:1}
  .sep{width:1px;height:28px;background:#555;margin:0 8px}
</style>
</head>
<body>
<div id="hud"><div id="hudText"></div></div>
<canvas id="sim"></canvas>
<div id="ui">
  <label>항성 온도(K) <input id="temp" type="range" min="3000" max="30000" step="100" value="5800"></label>
  <label>a(행성-항성 거리, px) <input id="a" type="range" min="120" max="1000" step="10" value="400"></label>
  <label>공전주기 T(초) <input id="period" type="range" min="4" max="120" step="1" value="20"></label>
  <label>속도 배율 x <input id="speedMul" type="range" min="0.1" max="5" step="0.1" value="1.0"></label>
  <span class="sep"></span>
  <label>이심률 e <input id="ecc" type="number" min="0" max="0.95" step="0.01" value="0.30"></label>
  <label>기울기 i(°) <input id="inc" type="number" min="0" max="180" step="0.1" value="25"></label>
  <label>Ω(°) <input id="Omega" type="number" min="0" max="360" step="0.1" value="30"></label>
  <label>ω(°) <input id="omega" type="number" min="0" max="360" step="0.1" value="45"></label>
  <span class="sep"></span>
  <label>항성 질량(M☉) <input id="mStar" type="number" min="0.01" max="50" step="0.01" value="1.00"></label>
  <label>행성 질량(M⊕) <input id="mPlanet" type="number" min="0.01" max="2000" step="0.01" value="1.00"></label>
  <button id="toggle">Start</button>
  <button id="reset">Center</button>
</div>

<script>
const cvs = document.getElementById('sim');
const ctx = cvs.getContext('2d');
const hud = document.getElementById('hudText');
const controls = {
  temp: document.getElementById('temp'),
  a: document.getElementById('a'),
  period: document.getElementById('period'),
  speedMul: document.getElementById('speedMul'),
  ecc: document.getElementById('ecc'),
  inc: document.getElementById('inc'),
  Omega: document.getElementById('Omega'),
  omega: document.getElementById('omega'),
  mStar: document.getElementById('mStar'),
  mPlanet: document.getElementById('mPlanet'),
  toggle: document.getElementById('toggle'),
  reset: document.getElementById('reset'),
  hudDiv: document.getElementById('hud'),
  uiDiv: document.getElementById('ui'),
};

function resize(){
  const hudH = controls.hudDiv.offsetHeight;
  const uiH  = controls.uiDiv.offsetHeight;
  cvs.width  = innerWidth;
  cvs.height = innerHeight - hudH - uiH;
  cvs.style.top = hudH + 'px';
}
addEventListener('resize', resize); resize();

// 상수
const MSUN=1.98847e30, MEARTH=5.972e24;

// 배경별
const stars = Array.from({length:320}, ()=> [Math.random()*innerWidth, Math.random()*innerHeight]);

// 회전/투영
function rotZ([x,y,z],a){const c=Math.cos(a),s=Math.sin(a);return [c*x - s*y, s*x + c*y, z];}
function rotX([x,y,z],a){const c=Math.cos(a),s=Math.sin(a);return [x, c*y - s*z, s*y + c*z];}
function project([x,y,z]){ return [x, y]; }

// 케플러
function solveKepler(M,e){
  M = (M%(2*Math.PI) + 2*Math.PI)%(2*Math.PI);
  let E = e<0.8 ? M : Math.PI;
  for(let k=0;k<50;k++){
    const f = E - e*Math.sin(E) - M;
    const fp= 1 - e*Math.cos(E);
    E -= f/fp;
    if(Math.abs(f) < 1e-9) break;
  }
  return E;
}

// 색상
function tempToRGB(temp){
  temp = Math.max(3000, Math.min(30000, temp))/1000;
  let r,g,b;
  if (temp<=10) r=255; else r=255 - (temp-10)*(255-180)/(30-10);
  if (temp<=10) g=150 + (temp-3)*(255-150)/(10-3); else g=255 - (temp-10)*(255-210)/(30-10);
  if (temp<=10) b=150 + (temp-3)*(255-150)/(10-3); else b=255;
  return `rgb(${r|0},${g|0},${b|0})`;
}

// 트레일
const trail = [];
const TRAIL_MAX = 300;

// 카메라
let scale = 1;
let pan = {x:0, y:0};
let dragging = false, lastMouse = {x:0,y:0};
cvs.addEventListener('mousedown', e=>{ dragging=true; lastMouse={x:e.clientX,y:e.clientY}; });
addEventListener('mouseup', ()=> dragging=false);
addEventListener('mousemove', e=>{
  if(!dragging) return;
  const dx = e.clientX - lastMouse.x;
  const dy = e.clientY - lastMouse.y;
  pan.x += dx; pan.y += dy;
  lastMouse = {x:e.clientX,y:e.clientY};
});
cvs.addEventListener('wheel', e=>{
  e.preventDefault();
  const factor = Math.exp(-e.deltaY*0.0015);
  const rect = cvs.getBoundingClientRect();
  const mx = (e.clientX - rect.left - pan.x) / scale;
  const my = (e.clientY - rect.top  - pan.y) / scale;
  scale *= factor;
  pan.x = e.clientX - rect.left - mx*scale;
  pan.y = e.clientY - rect.top  - my*scale;
}, {passive:false});

// 제어
let running=false;
controls.toggle.onclick = ()=>{ running = !running; controls.toggle.textContent = running ? 'Pause' : 'Start'; };
controls.reset.onclick  = ()=>{ pan.x=0; pan.y=0; scale=1; trail.length=0; };

// 시간
let t=0, last=performance.now();

// 공용 궤도
function orb2D(aVal, phase, e, inc, Om, om){
  const r = aVal*(1-e*e)/(1+e*Math.cos(phase));
  let v = [ r*Math.cos(phase), r*Math.sin(phase), 0 ];
  v = rotZ(v, om);
  v = rotX(v, inc);
  v = rotZ(v, Om);
  return project(v);
}

function frame(now){
  const dt = (now - last)/1000; last = now;
  const speedMul = parseFloat(controls.speedMul.value);
  if(running) t += dt * speedMul;

  // 입력값
  const TEMP   = parseFloat(controls.temp.value);
  const aTot   = parseFloat(controls.a.value);
  const Tsec   = parseFloat(controls.period.value);
  const e      = Math.max(0, Math.min(0.95, parseFloat(controls.ecc.value) || 0));
  const inc    = (parseFloat(controls.inc.value)||0)    * Math.PI/180;
  const Om     = (parseFloat(controls.Omega.value)||0)  * Math.PI/180;
  const om     = (parseFloat(controls.omega.value)||0)  * Math.PI/180;
  const mStarM = Math.max(1e-6, parseFloat(controls.mStar.value)||1);
  const mPlM   = Math.max(1e-6, parseFloat(controls.mPlanet.value)||1);

  const mStar = mStarM * MSUN, mPl = mPlM * MEARTH;
  const totM  = mStar + mPl;
  const a_star   = aTot * (mPl / totM);
  const a_planet = aTot * (mStar / totM);

  const n = 2*Math.PI / Tsec;
  const M = n * t;
  const E = solveKepler(M, e);
  const cosE=Math.cos(E), sinE=Math.sin(E);
  const cosf=(cosE - e)/(1 - e*cosE);
  const sinf=Math.sqrt(1 - e*e)*sinE/(1 - e*cosE);
  const f = Math.atan2(sinf, cosf);

  // 화면 초기화
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,cvs.width,cvs.height);
  for(const [sx,sy] of stars){ ctx.fillStyle="#fff"; ctx.fillRect(sx, sy, 1, 1); }
  ctx.setTransform(scale,0,0,scale, pan.x + cvs.width/2, pan.y + cvs.height/2);

  // 궤도 타원
  ctx.strokeStyle = "rgba(150,150,150,0.7)";
  ctx.beginPath();
  for(let ang=0; ang<=Math.PI*2; ang+=0.02){
    const p = orb2D(a_planet, ang, e, inc, Om, om);
    if(ang===0) ctx.moveTo(p[0], p[1]); else ctx.lineTo(p[0], p[1]);
  }
  ctx.stroke();

  const P = orb2D(a_planet, f,         e, inc, Om, om);
  const S = orb2D(a_star,   f+Math.PI, e, inc, Om, om);

  trail.push([P[0], P[1]]);
  if(trail.length > 300) trail.shift();

  // 트레일
  if(trail.length>1){
    ctx.lineWidth=2/scale;
    for(let i=1;i<trail.length;i++){
      const a=i/trail.length;
      ctx.strokeStyle=`rgba(100,200,255,${0.15+0.6*a})`;
      ctx.beginPath();
      ctx.moveTo(trail[i-1][0],trail[i-1][1]);
      ctx.lineTo(trail[i][0],trail[i][1]);
      ctx.stroke();
    }
  }

  // 항성
  ctx.fillStyle=tempToRGB(TEMP);
  ctx.beginPath();ctx.arc(S[0],S[1],24,0,Math.PI*2);ctx.fill();

  // 행성 + 위상
  const planetR=10;
  ctx.fillStyle="rgb(40,60,80)";
  ctx.beginPath();ctx.arc(P[0],P[1],planetR,0,Math.PI*2);ctx.fill();
  const lx=S[0]-P[0],ly=S[1]-P[1],L=Math.hypot(lx,ly)||1;
  const ux=lx/L,uy=ly/L;
  ctx.fillStyle="rgb(120,200,255)";
  ctx.beginPath();ctx.arc(P[0]+ux*planetR*0.6,P[1]+uy*planetR*0.6,planetR,0,Math.PI*2);
  ctx.globalAlpha=0.75;ctx.fill();ctx.globalAlpha=1;

  // ✅ 마지막에 COM 표시 (항성·행성 위에도 항상 보임)
  ctx.strokeStyle="red"; ctx.lineWidth=2/scale;
  ctx.beginPath();
  ctx.moveTo(-8,0); ctx.lineTo(8,0);
  ctx.moveTo(0,-8); ctx.lineTo(0,8);
  ctx.stroke();

  hud.innerHTML=`속도배율 x${speedMul.toFixed(1)} | e=${e.toFixed(2)} | i=${(inc*180/Math.PI).toFixed(1)}° | Ω=${(Om*180/Math.PI).toFixed(1)}° | ω=${(om*180/Math.PI).toFixed(1)}°<br>COM(빨간 X)은 항상 최상단에 표시됨`;
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
